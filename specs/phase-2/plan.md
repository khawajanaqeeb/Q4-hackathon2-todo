# Phase II Architectural Plan: Todo Full-Stack Web Application

**Branch**: `phase2-fullstack` | **Date**: 2026-01-02 | **Spec**: [specs/phase-2/spec.md](./spec.md)
**Input**: Feature specification from `/specs/phase-2/spec.md`

**Note**: This template is filled in by the `/sp.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Transform the Phase I console-based todo application into a production-ready full-stack web application with multi-user support, authentication, persistent cloud storage (Neon PostgreSQL), modern responsive UI (Next.js 16+ with App Router), RESTful API backend (FastAPI with async support), and all Basic + Intermediate features. Implementation follows the Hackathon II PDF guidelines using Next.js, FastAPI, SQLModel, Neon Serverless PostgreSQL, Better Auth with JWT, and deploys to Vercel (frontend) and Railway/Render (backend).

## Technical Context

**Language/Version**: Python 3.11+ (backend), TypeScript 5.x + Node.js 18+ (frontend)
**Primary Dependencies**: Next.js 16+ (App Router), FastAPI 0.100+, SQLModel, Neon PostgreSQL, Better Auth with JWT
**Storage**: Neon Serverless PostgreSQL (cloud database, no local files)
**Testing**: pytest (backend), Jest + React Testing Library (frontend), Playwright (E2E)
**Target Platform**: Web application (responsive: mobile, tablet, desktop), deployed to Vercel (frontend) and Railway/Render (backend)
**Project Type**: Full-stack web application (separate frontend and backend services)
**Performance Goals**: API response time <200ms (p95) for list queries, <100ms (p95) for single-item queries, Lighthouse performance 90+, accessibility 95%
**Constraints**: Neon DB only (no local SQLite files), user isolation (users see only their tasks), JWT authentication with 30-minute expiry, 80%+ backend coverage, 70%+ frontend coverage
**Scale/Scope**: Support 100 concurrent users (Phase II target), 10,000 tasks per user, 1,000 requests/min (rate limit)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

✅ **Principle I - Spec-Driven Development**: All code generated by Claude Code from specs/phase-2/spec.md
✅ **Principle II - Agentic Dev Stack Workflow**: Following Specify → Plan → Tasks → Implement → Validate sequence
✅ **Principle III - Phase-Based Evolution**: Phase II builds on Phase I foundation with explicit phase directory structure
✅ **Principle IV - Technology Stack Constraints**: Using Phase II prescribed stack (Next.js, FastAPI, SQLModel, Neon, Better Auth, Vercel, Railway)
✅ **Principle V - Feature Progression**: Implements all Basic features (Add, Delete, Update, View, Mark Complete) and Intermediate features (Priorities, Tags, Search, Filter, Sort)
✅ **Principle VI - Code Quality**: Python PEP 8 + type hints, TypeScript strict mode, 80%+ backend coverage, 70%+ frontend coverage
✅ **Principle VII - Security & Safety**: JWT auth, bcrypt password hashing, user isolation, SQL injection prevention, CORS, HTTPS, rate limiting
✅ **Principle VIII - Documentation Excellence**: README.md per phase, CLAUDE.md, specs/, history/prompts/, history/adr/
✅ **Principle IX - Submission Standards**: GitHub repo, deployed URLs (Vercel + Railway), demo video <90s, git tags
✅ **Principle X - Reusable Intelligence**: Custom agents and skills created for Phase II (bonus points eligible)

**Gate Result**: ✅ PASS - All constitutional principles satisfied

## Project Structure

### Documentation (this feature)

```text
specs/phase-2/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (/sp.plan command)
├── data-model.md        # Phase 1 output (/sp.plan command)
├── quickstart.md        # Phase 1 output (/sp.plan command)
├── contracts/           # Phase 1 output (/sp.plan command)
│   ├── auth.yaml       # Authentication endpoints (OpenAPI)
│   └── todos.yaml      # Todo CRUD endpoints (OpenAPI)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
phase2-fullstack/          # Phase II root directory
├── backend/               # FastAPI backend service
│   ├── app/              # Python package (REQUIRED: prevents ModuleNotFoundError)
│   │   ├── __init__.py  # Package marker (can be empty but MUST exist)
│   │   ├── main.py      # FastAPI app entry point (app = FastAPI())
│   │   ├── config.py    # Settings from environment variables
│   │   ├── database.py  # SQLModel engine and session management
│   │   ├── models/      # SQLModel table definitions
│   │   │   ├── __init__.py
│   │   │   ├── user.py  # User table model
│   │   │   └── todo.py  # Todo table model
│   │   ├── schemas/     # Pydantic request/response schemas
│   │   │   ├── __init__.py
│   │   │   ├── user.py  # UserCreate, UserResponse, LoginRequest
│   │   │   └── todo.py  # TodoCreate, TodoUpdate, TodoResponse
│   │   ├── routers/     # API route handlers
│   │   │   ├── __init__.py
│   │   │   ├── auth.py  # /auth endpoints (register, login)
│   │   │   └── todos.py # /todos CRUD endpoints
│   │   ├── dependencies/
│   │   │   ├── __init__.py
│   │   │   ├── auth.py     # get_current_user (JWT validation)
│   │   │   └── database.py # get_session (DB lifecycle)
│   │   └── utils/
│   │       ├── __init__.py
│   │       └── security.py # Password hashing, JWT creation/validation
│   ├── alembic/          # Database migrations
│   │   ├── env.py
│   │   └── versions/
│   ├── tests/            # Backend test suite
│   │   ├── __init__.py
│   │   ├── conftest.py   # Shared fixtures
│   │   ├── test_auth.py  # Auth endpoint tests
│   │   └── test_todos.py # Todo CRUD tests
│   ├── scripts/
│   │   └── seed.py       # Optional database seeding
│   │   └── migrate_middleware.py # Script to migrate middleware to proxy pattern
│   ├── .env              # Environment variables (gitignored)
│   ├── .env.example      # Template for .env
│   ├── requirements.txt  # Python dependencies
│   └── alembic.ini       # Alembic configuration
│
├── frontend/             # Next.js frontend application
│   ├── app/             # Next.js App Router structure
│   │   ├── layout.tsx   # Root layout
│   │   ├── page.tsx     # Home page (redirects to /dashboard or /login)
│   │   ├── login/
│   │   │   └── page.tsx # Login page
│   │   ├── register/
│   │   │   └── page.tsx # Registration page
│   │   └── dashboard/
│   │       ├── layout.tsx  # Dashboard layout (protected)
│   │       └── page.tsx    # Main todo list with advanced task table
│   ├── components/      # React components
│   │   ├── auth/
│   │   │   ├── LoginForm.tsx
│   │   │   └── RegisterForm.tsx
│   │   ├── todos/
│   │   │   ├── TodoTable.tsx      # Advanced table with search/filter/sort
│   │   │   ├── TodoCard.tsx       # Mobile card view
│   │   │   ├── AddTaskForm.tsx    # Add task modal
│   │   │   ├── EditTaskForm.tsx   # Edit task form
│   │   │   ├── FilterBar.tsx      # Advanced search/filter controls
│   │   │   └── TodoRow.tsx        # Single todo row
│   │   └── ui/
│   │       ├── Button.tsx
│   │       ├── Input.tsx
│   │       ├── Modal.tsx
│   │       ├── Toast.tsx
│   │       └── Spinner.tsx
│   ├── lib/
│   │   ├── api.ts              # API client functions
│   │   ├── auth.ts             # Auth utilities (getToken, logout)
│   │   └── utils.ts            # Helpers (cn, formatDate)
│   ├── types/
│   │   ├── user.ts             # User TypeScript interfaces
│   │   └── todo.ts             # Todo TypeScript interfaces
│   ├── context/
│   │   └── AuthContext.tsx     # Global auth state
│   ├── middleware.ts           # Route protection (TO BE REPLACED: deprecated, use app/api/auth/proxy or server actions)
│   ├── app/api/auth/proxy/route.ts # NEW: Proxy route for authentication (replaces middleware)
│   ├── tests/                  # Frontend tests
│   │   ├── components/
│   │   └── integration/
│   ├── .env.local             # Environment variable template
│   ├── package.json
│   ├── tsconfig.json
│   └── tailwind.config.js
│
├── docker-compose.yml          # Local development orchestration
└── README.md                   # Phase II documentation
```

**Structure Decision**: Chosen **Web application** structure with separate `backend/` and `frontend/` directories as this is a full-stack application requiring independent deployment of API (Railway/Render) and UI (Vercel). The backend follows the corrected FastAPI package structure specified in the spec to prevent ModuleNotFoundError:

- Working directory: `phase2-fullstack/backend/`
- Python package: `app/` with `__init__.py`
- Entry point: `app/main.py` with `app = FastAPI()`
- Uvicorn command: `uvicorn app.main:app --reload --host 0.0.0.0 --port 8000`

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| (None) | (No violations detected) | (All constitutional principles satisfied) |

---

## Phase 0: Research & Technology Decisions

All technical decisions are **pre-specified** by the Phase II technology stack in the constitution and feature specification. No open-ended research required. The following documents the rationale for each prescribed technology:

#### 1. Frontend Framework: Next.js 16+ with App Router

**Decision**: Next.js 16+ (App Router, TypeScript, Tailwind CSS)

**Rationale**:
- Server components for improved performance and SEO
- Built-in routing with file-system based structure
- Automatic code splitting and optimization
- Excellent developer experience with hot reload
- TypeScript support out-of-the-box
- Tailwind CSS integration for rapid UI development
- Vercel deployment optimization (same company)

**Alternatives Considered**: Create React App (deprecated), Vite + React (requires more setup)

**Best Practices**:
- Use App Router (not Pages Router) for server components
- Implement route protection via middleware.ts
- Store JWT in httpOnly cookies OR localStorage (localStorage chosen for simplicity)
- Use React Server Components where possible, Client Components only when needed
- Implement error boundaries for graceful error handling
- Use loading.tsx and error.tsx for better UX

#### 2. Backend Framework: FastAPI with SQLModel

**Decision**: FastAPI 0.100+ with SQLModel ORM

**Rationale**:
- Async/await support for high-performance I/O operations
- Automatic OpenAPI documentation generation
- Type hints with Pydantic for request/response validation
- SQLModel combines SQLAlchemy + Pydantic for type-safe database operations
- Excellent integration with PostgreSQL via asyncpg
- Dependency injection system for clean architecture
- Built-in validation and serialization

**Alternatives Considered**: Django REST Framework (heavier, synchronous), Flask (requires more boilerplate)

**Best Practices**:
- Use dependency injection for database sessions and authentication
- Implement proper CORS configuration for frontend-backend communication
- Use Alembic for database migrations (version control for schema)
- Separate models (database tables) from schemas (request/response)
- Use HTTPException with proper status codes
- Implement rate limiting for auth endpoints

#### 3. Database: Neon Serverless PostgreSQL

**Decision**: Neon PostgreSQL with connection pooling

**Rationale**:
- Serverless architecture (auto-scaling, auto-pause)
- Generous free tier (3GB storage)
- SSL required by default (security)
- Fully managed (no infrastructure maintenance)
- PostgreSQL 15 features (JSONB for tags array)
- Excellent for development and small-scale production

**Alternatives Considered**: Railway PostgreSQL (more expensive), Supabase (includes unnecessary features)

**Best Practices**:
- Use connection pooling (SQLAlchemy engine pool_size=10, max_overflow=20)
- Always use parameterized queries (SQLModel handles this)
- Create indexes on foreign keys and frequently queried columns
- Use database constraints for data integrity (UNIQUE, NOT NULL, CHECK)
- Enable SSL mode (required by Neon)
- Use Alembic migrations for schema changes (never manual SQL)

#### 4. Authentication: JWT with Better Auth

**Decision**: JWT tokens with python-jose + passlib for bcrypt

**Rationale**:
- Stateless authentication (no server-side session storage)
- Secure password hashing with bcrypt (cost factor 12+)
- Token-based auth works well with REST APIs
- Frontend can easily attach tokens to requests
- 30-minute expiry reduces attack surface

**Alternatives Considered**: Session-based auth (requires session store), OAuth2 (overkill for Phase II)

**Best Practices**:
- Store JWT secret in environment variable (min 256 bits)
- Use HS256 algorithm (symmetric signing)
- Include minimal claims in JWT (user_id, email, expiry)
- Implement token expiry and validation on every request
- Use HTTPBearer security scheme in FastAPI
- Never include password or sensitive data in JWT
- Implement rate limiting on login endpoint (5 attempts/min)

#### 5. Deployment: Vercel + Railway/Render

**Decision**: Vercel (frontend), Railway or Render (backend)

**Rationale**:
- Vercel: Optimized for Next.js, automatic HTTPS, CDN, zero config
- Railway/Render: Easy Docker deployment, environment variables, auto-deploy from GitHub
- Both offer generous free tiers
- Separate deployment allows independent scaling

**Alternatives Considered**: Netlify (less Next.js optimization), Heroku (no longer free)

**Best Practices**:
- Use environment variables for all secrets (DATABASE_URL, SECRET_KEY)
- Configure CORS to allow only frontend origin
- Set up automatic deployment from GitHub
- Use health check endpoints (/health)
- Monitor deployment logs for errors
- Use Docker for backend containerization (reproducible builds)

### Research Output File

All research findings will be consolidated in `specs/phase-2/research.md` documenting:
- Technology stack decisions (rationale + alternatives)
- Security patterns (JWT, bcrypt, user isolation)
- API design patterns (REST conventions, error handling)
- Frontend patterns (React hooks, state management)
- Database patterns (migrations, indexing, connection pooling)

---

## Phase 1: Design & Contracts

### Data Model

The data model will be documented in `specs/phase-2/data-model.md` with:

**Entity 1: User**
- Primary Key: `id` (auto-increment integer)
- Unique Index: `email` (string, max 255 chars)
- Fields: `hashed_password` (bcrypt hash, 60 chars), `name` (string, max 255), `is_active` (boolean, default true)
- Timestamps: `created_at`, `updated_at` (auto-generated)
- Relationships: One-to-many with Todo (cascade delete)

**Entity 2: Todo**
- Primary Key: `id` (auto-increment integer)
- Foreign Key: `user_id` (references users.id, indexed, NOT NULL)
- Fields: `title` (string, 1-500 chars, required), `description` (text, optional, max 5000), `completed` (boolean, default false), `priority` (enum: low/medium/high, default medium), `tags` (JSON array, max 10 strings)
- Timestamps: `created_at`, `updated_at` (auto-generated)
- Indexes: user_id, completed, priority, created_at, title (for performance)
- Relationships: Many-to-one with User

**State Transitions**:
- Todo.completed: false ⇄ true (toggle operation)
- User.is_active: true → false (soft delete, prevents login)

**Validation Rules**:
- User.email: Valid email format (Pydantic EmailStr), unique constraint
- User.password: Min 8 chars (frontend), bcrypt hashed (backend)
- Todo.title: 1-500 chars, trimmed, non-empty
- Todo.description: Max 5000 chars, optional
- Todo.tags: Array of max 10 strings, each max 50 chars

### API Contracts

API contracts will be generated in OpenAPI 3.0 format at `specs/phase-2/contracts/`:

**File: auth.yaml**
- POST /auth/register: Create new user account
- POST /auth/login: Authenticate user and return JWT token

**File: todos.yaml**
- GET /todos: List all user's todos (with query params: skip, limit, completed, priority, search, sort_by, sort_order)
- POST /todos: Create new todo item
- GET /todos/{id}: Get single todo item
- PUT /todos/{id}: Update todo item
- DELETE /todos/{id}: Delete todo item
- POST /todos/{id}/toggle: Toggle completed status

All endpoints follow REST conventions:
- Authentication: Bearer token in Authorization header (except register/login)
- Success: 200 (OK), 201 (Created), 204 (No Content)
- Errors: 400 (Bad Request), 401 (Unauthorized), 404 (Not Found), 422 (Validation Error), 429 (Too Many Requests)
- Content-Type: application/json
- User isolation: All /todos/* endpoints filter by current_user.id automatically

### Quickstart Guide

The quickstart guide (`specs/phase-2/quickstart.md`) will provide:
- Prerequisites (Node.js 18+, Python 3.11+, Neon account)
- Backend setup (venv, pip install, env vars, alembic migrate, uvicorn run)
- Frontend setup (npm install, env vars, npm run dev)
- Local testing (register user, create tasks, verify features)
- Deployment instructions (Vercel frontend, Railway backend)

### Agent Context Update

After Phase 1 design completion, run:
```bash
powershell.exe -ExecutionPolicy Bypass -File .specify/scripts/powershell/update-agent-context.ps1 -AgentType claude
```

This will update `.specify/memory/agent-context.md` with:
- Phase II technology stack (Next.js, FastAPI, SQLModel, Neon)
- API contract references (auth.yaml, todos.yaml)
- Data model summary (User, Todo entities)
- Deployment targets (Vercel, Railway/Render)

### Constitution Re-check

After Phase 1 design completion, re-check constitution compliance:
- All technology stack constraints followed
- Security requirements implemented
- Feature progression discipline maintained
- Code quality standards documented
- Documentation excellence requirements met

---

## Phase 2: Task Breakdown (Handled by /sp.tasks)

**Note**: This phase is NOT executed by `/sp.plan`. After completing Phase 1, run `/sp.tasks` to generate atomic task breakdown for implementation.

---

## Architecture Decision Records (ADRs)

The following architecturally significant decisions should be documented in `history/adr/` if not already captured:

1. **ADR-001: Separate Frontend/Backend Deployment**
   - Decision: Deploy frontend (Vercel) and backend (Railway) independently
   - Rationale: Different scaling characteristics, technology stacks, deployment requirements
   - Alternatives: Monolithic Next.js API routes (limited backend flexibility)

2. **ADR-002: JWT Token Storage in localStorage**
   - Decision: Store JWT tokens in localStorage (not httpOnly cookies)
   - Rationale: Simplicity for Phase II, easier CORS handling, frontend-controlled token lifecycle
   - Alternatives: httpOnly cookies (more secure but complex CORS), sessionStorage (lost on tab close)
   - Trade-off: Vulnerable to XSS (mitigated by React auto-escaping and input validation)

3. **ADR-003: SQLModel ORM over Raw SQL**
   - Decision: Use SQLModel for all database operations
   - Rationale: Type safety, automatic validation, SQL injection prevention, cleaner code
   - Alternatives: Raw SQL with psycopg3 (more control but error-prone)

4. **ADR-004: App Router over Pages Router (Next.js)**
   - Decision: Use Next.js 16+ App Router (not Pages Router)
   - Rationale: Future-proof, server components, better performance, improved developer experience
   - Alternatives: Pages Router (legacy, being phased out)

5. **ADR-005: Middleware Migration to Proxy Pattern**
   - Decision: Migrate from deprecated middleware.ts to new proxy pattern
   - Rationale: Next.js 16+ deprecates middleware file convention, requires new approach
   - Alternatives: Continue using deprecated middleware (not sustainable)
   - Implementation: Use API routes in app/api/auth/proxy/ for authentication checks

---

## Implementation Readiness Checklist

Before proceeding to `/sp.tasks`:

- [x] Phase 0: Research completed (all technology decisions documented in research.md)
- [x] Phase 1: Data model defined (data-model.md with User and Todo entities)
- [x] Phase 1: API contracts generated (contracts/auth.yaml, contracts/todos.yaml)
- [x] Phase 1: Quickstart guide created (quickstart.md with setup instructions)
- [x] Agent context updated (technology stack added to agent-specific context file)
- [x] Constitution re-checked (no violations introduced during design)
- [x] All NEEDS CLARIFICATION markers resolved (none present in this plan)

**Next Command**: `/sp.tasks` to generate atomic task breakdown for implementation

---

**Plan Version**: 1.0
**Last Updated**: 2026-01-02
**Status**: Ready for task generation